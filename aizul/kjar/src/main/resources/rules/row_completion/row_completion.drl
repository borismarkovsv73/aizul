package rules.backward

import com.ftn.sbnz.model.models.Move;
import com.ftn.sbnz.model.models.Board;
import com.ftn.sbnz.model.models.Tile;
import com.ftn.sbnz.model.models.Player;
import com.ftn.sbnz.model.models.GameState;
import com.ftn.sbnz.model.strategy.StrategicGoal;
import com.ftn.sbnz.model.strategy.GoalJustification;

query "howToCompleteRowsAtDepth"
    $move : Move()
    $board : Board($wall : wall)
    $depth : Integer() from [1, 2, 3]
    eval(canMoveHelpWithRowCompletion($wall, $move.getTargetRow(), $move, $depth))
end

query "whichRowsNeedWork"
    $board : Board($wall : wall)
    $row : Integer() from [0, 1, 2, 3, 4]
    $depth : Integer() from [1, 2, 3]
    eval(isRowMissingExactly($wall, $row, $depth))
end

rule "Recursive Row Completion Strategy"
    salience 100
    no-loop true
    when
        $board : Board($wall : wall)
        $row : Integer() from [0, 1, 2, 3, 4]
        $depth : Integer() from [1, 2, 3]
        eval(isRowMissingExactly($wall, $row, $depth))
        not StrategicGoal(type == "COMPLETE_ROW_" + $row + "_" + $depth)
    then
        int bonusPoints = Math.max(5, 25 - ($depth * 5));
        StrategicGoal recursiveGoal = new StrategicGoal("COMPLETE_ROW_" + $row + "_" + $depth, $row, $depth, bonusPoints, true);
        insert(recursiveGoal);
        System.out.println("RECURSIVE [Depth " + $depth + "]: Row " + $row + " needs " + $depth + " tiles");
end

rule "Find Recursive Answer"
    salience 90
    no-loop true
    when
        $question : StrategicGoal(type.startsWith("COMPLETE_ROW_"), $targetRow : targetRow, $depth : targetCol)
        $move : Move(targetRow == $targetRow)
        $board : Board($wall : wall)
        eval(canMoveHelpWithRowCompletion($wall, $targetRow, $move, $depth))
        not GoalJustification(goal == $question, move == $move)
    then
        GoalJustification answer = new GoalJustification();
        answer.setGoal($question);
        answer.setMove($move);
        answer.setReasoning("Depth " + $depth + ": Move helps row " + $targetRow + " completion");
        insert(answer);
end

rule "Apply Strategic Bonus"
    salience 80
    no-loop true
    when
        $move : Move($originalScore : score)
        $answer : GoalJustification(move == $move, $question : goal)
        $strategicGoal : StrategicGoal(this == $question, $priority : priority, $depth : targetCol, achievable == true)
        $gameState : GameState($players : players)
        $currentPlayer : Player() from $players
        eval(shouldApplyStrategicBonus($gameState, $currentPlayer, $move, $priority))
        not StrategicGoal(type == "BONUS_APPLIED_" + $move.hashCode())
    then
        int newScore = $originalScore + $priority;
        $move.setScore(newScore);
        StrategicGoal bonusTracker = new StrategicGoal("BONUS_APPLIED_" + $move.hashCode(), -1, $depth, 0, false);
        insert(bonusTracker);
end

function boolean isRowMissingExactly(Tile[][] wall, int targetRow, int missingCount) {
    if (targetRow < 0 || targetRow >= wall.length) return false;
    
    int filledCount = 0;
    for (int col = 0; col < wall[targetRow].length; col++) {
        if (wall[targetRow][col] != null) {
            filledCount++;
        }
    }
    
    return filledCount == (wall[targetRow].length - missingCount);
}

function boolean canMoveHelpWithRowCompletion(Tile[][] wall, int targetRow, Move move, int depth) {
    if (targetRow < 0 || targetRow >= wall.length) return false;
    if (move.getTargetRow() != targetRow) return false;
    
    int emptyPositions = 0;
    for (int col = 0; col < wall[targetRow].length; col++) {
        if (wall[targetRow][col] == null) {
            emptyPositions++;
        }
    }
    
    return emptyPositions == depth;
}

function boolean shouldApplyStrategicBonus(GameState gameState, Player currentPlayer, Move move, int bonusPoints) {
    java.util.List<Player> players = gameState.getPlayers();
    if (players.size() < 2) return true;
    
    int currentPlayerScore = currentPlayer.getScore();
    int highestOpponentScore = 0;
    
    for (Player player : players) {
        if (!player.getId().equals(currentPlayer.getId()) && player.getScore() > highestOpponentScore) {
            highestOpponentScore = player.getScore();
        }
    }
    
    boolean isCurrentlyWinning = currentPlayerScore > highestOpponentScore;
    boolean wouldBecomeWinning = (currentPlayerScore + bonusPoints) > highestOpponentScore;
    
    return isCurrentlyWinning || wouldBecomeWinning;
}